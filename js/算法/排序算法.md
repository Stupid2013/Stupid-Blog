### 排序算法

1、冒泡排序
```javascript
const order = [6, 3, 8, 2, 9, 1];
for(let i = 0; i < order.length - 1; i++){ //外层循环控制排序趟数
  for(let j = 0; j < order.length - 1 - i; j++){ //内层循环控制每一趟排序多少次
    if(order[j] > order[j+1]){
      let temp = order[j];
      order[j] = order[j+1];
      order[j+1] = temp;
    }
  }
}
```
原理：相邻的两个元素进行比较，将值大的元素交换至右边。

实现：

第一趟排序：

　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1

　　　　第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1

　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1

　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1

　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9

　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9

---

第二趟排序：

　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9

　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9

　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9

　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9

　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9

---

第三趟排序：

　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9

　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9

　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9

　　　　第二趟总共进行了3次比较， 排序结果：     2  3  1  6  8  9

---

第四趟排序：

　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9

　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9

　　　　第二趟总共进行了2次比较， 排序结果：     2  1  3  6  8  9

---

第五趟排序：

　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9

　　　　第二趟总共进行了1次比较， 排序结果：      1  2  3  6  8  9

---

最终结果：1  2  3  6  8  9

---

由此可见：`n`个数字要排序完成，总共进行`n-1`趟排序，每i趟的排序次数为`(n-i)`次.

冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。

参考文章：

  [Java中的经典算法之冒泡排序(Bubble Sort)](https://www.cnblogs.com/shen-hua/p/5422676.html)
